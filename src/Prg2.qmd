---
title: "Test librairie fichier PDF"
format: html
---

## üîß Chargement des biblioth√®ques

```{python}
# 1. Installation des d√©pendances
# 'Accelerate' et 'bitsandbytes' pour optimiser l'utilisation du GPU
# 'pypdf' pour la manipulation des fichiers PDF
# 'Pillow' pour le traitement d'images

!pip install -q transformers accelerate bitsandbytes torch pypdf Pillow

# 'pdf2image' sert √† convertir des pages PDF en images
!pip install -q pdf2image

print("‚úÖ Installation termin√©e.")
```

## üîß Installation de la d√©pendance syst√®me (Poppler)

```{python install-poppler, eval=FALSE}
# eval=FALSE : Ne pas ex√©cuter √† chaque fois. D√©commenter et ex√©cuter UNE SEULE FOIS.
# Installe les outils Poppler (n√©cessaires √† pdf2image) sur la machine Linux du conteneur.

# ‚ö†Ô∏è ATTENTION : Si la commande 'apt' ne fonctionne pas, il se peut que votre conteneur utilise 'conda'.
# Si c'est le cas, remplacez les lignes ci-dessous par: 
#!conda install -y poppler

sudo apt update
sudo apt install poppler-utils -y

print("‚úÖ Poppler-utils (d√©pendance syst√®me) install√©.")
```

## üîß Importation des biblioth√®ques

```{python import-libs}
# 2. Importation


import os
import json # NOUVEAU : pour manipuler les donn√©es JSON
from transformers import AutoTokenizer, AutoModelForCausalLM, pipeline
from pypdf import PdfReader
from pdf2image import convert_from_path
from PIL import Image
import torch

print("üì¶ Biblioth√®ques import√©es avec succ√®s.")
```

## üîß Chargement du fichier pdf

```{python load-file}
import os
from pypdf import PdfReader # <-- AJOUTER CETTE LIGNE

# --- CHANGEMENT DE R√âPERTOIRE DE TRAVAIL ---
# D√©finir le chemin cible : la racine du projet
racine_projet = "/home/onyxia/work/Projet-Methodologie/" 

# Changer le r√©pertoire de travail vers la racine du projet
try:
    os.chdir(racine_projet)
    print(f"‚úÖ Nouveau r√©pertoire de travail d√©fini sur : {os.getcwd()}")
except Exception as e:
    print(f"‚ùå ERREUR: Impossible de changer de r√©pertoire vers {racine_projet}. V√©rifiez le chemin. Erreur: {e}")
    # Nous continuons quand m√™me, mais le chemin relatif pourrait √©chouer
    
# --- Configuration du chemin ---
fichier_pdf = "INSEE-etude118.pdf"
repertoire_entree = "input_files"
# Le chemin complet est maintenant calcul√© √† partir de la racine
chemin_complet = os.path.join(repertoire_entree, fichier_pdf)

# V√©rification de l'existence du fichier
if not os.path.exists(chemin_complet):
    # La v√©rification se fait maintenant √† partir de /home/onyxia/work/Projet-Methodologie/
    print(f"‚ùå ERREUR FATALE: Le fichier est introuvable √† l'emplacement '{chemin_complet}'.")
    raise FileNotFoundError("Le fichier PDF est manquant ou le chemin est incorrect. Assurez-vous que le dossier 'input_files' existe √† la racine du nouveau r√©pertoire de travail.")
else:
    print(f"‚úÖ Chemin de fichier v√©rifi√© : {chemin_complet}")

# --- Lecture du texte (pypdf) ---
try:
    reader = PdfReader(chemin_complet)
    num_pages = len(reader.pages)
    print(f"üìÑ Document lu. Nombre de pages : {num_pages}")
except Exception as e:
    print(f"‚ùå ERREUR inattendue lors de la lecture du PDF : {e}")
```

## Conversion en images des pages

```{python convert-images}
## Conversion en images des pages

from pdf2image import convert_from_path 

# Note : L'argument poppler_path a √©t√© retir√©. pdf2image recherche 'pdftoppm' 
# directement dans le PATH du syst√®me apr√®s l'installation via sudo apt.

try:
    # pages_images est une liste d'objets PIL.Image
    pages_images = convert_from_path(
        chemin_complet
        # poppler_path n'est plus n√©cessaire ici
    )
    print(f"üñºÔ∏è {len(pages_images)} pages converties en objets Image avec succ√®s.")
except Exception as e:
    # Si cette erreur se produit, cela signifie que poppler a √©t√© d√©sinstall√© ou n'est plus dans le PATH.
    print(f"‚ùå ERREUR lors de la conversion en images. La d√©pendance syst√®me Poppler est manquante. Erreur: {e}")
```



## üîß Analyse du fichier pdf

## üí° Note : La simulation de l'analyse par LLM est utilis√©e ici. 
## En r√©alit√©, le code r√©el ferait appel √† AutoModelForCausalLM.generate.

```{python analyze}
# --- 1. Extraction du texte ---
texte_integral = ""
try:
    # On r√©utilise le lecteur du bloc pr√©c√©dent, sinon il faudrait le re-cr√©er
    # Assurez-vous d'ex√©cuter tous les blocs s√©quentiellement.
    for page in reader.pages:
        texte_integral += page.extract_text()
    
    print(f"Extraction du texte r√©ussie. {len(texte_integral)} caract√®res extraits.")

except NameError:
    # Gestion d'erreur au cas o√π 'reader' ne serait pas d√©fini (si le bloc 2 n'a pas √©t√© ex√©cut√©)
    print("‚ùå ERREUR: Le lecteur de PDF (reader) n'est pas d√©fini. Ex√©cutez le bloc 2 d'abord.")
    raise

# --- 2. Initialisation du Mod√®le VLM (Document Question Answering) ---

# Mod√®le VLM pour l'analyse de documents
MODEL_VLM_NAME = "impira/layoutlm-document-qa"

try:
    # Tente d'utiliser le GPU si disponible
    device = 0 if torch.cuda.is_available() else -1 
    
    # Le pipeline g√®re le tokenizer, le mod√®le, et le post-traitement.
    vlm_qa_pipeline = pipeline(
        "document-question-answering",
        model=MODEL_VLM_NAME,
        device=device
    )
    print(f"‚úÖ Mod√®le VLM '{MODEL_VLM_NAME}' charg√© sur le device: {'GPU' if device == 0 else 'CPU'}.")

except Exception as e:
    print(f"‚ùå ERREUR lors du chargement du mod√®le VLM. V√©rifiez l'installation et la m√©moire : {e}")
    # Le code ci-dessous ne pourra pas s'ex√©cuter si le mod√®le ne charge pas.
    raise
```

## Analyse VLM


```{python analyze-and-export}
# --- 3. Structuration de la Sortie JSON ---
# La variable resultat_analyse_vlm doit √™tre d√©finie ici ou r√©utilis√©e du bloc pr√©c√©dent

# Cr√©ation du dictionnaire JSON avec les r√©sultats de l'analyse VLM
resultat_analyse_vlm = {
    "source_fichier": fichier_pdf,
    "chemin_relatif_entree": os.path.join(repertoire_entree, fichier_pdf),
    "nombre_pages": num_pages,
    "analyse_vlm": {
        # La variable 'reponse_titre' vient du bloc 'analyze' et contient le r√©sultat du VLM
        "titre_etude_vlm": reponse_titre, 
        "resultats_chiffres": "N√©cessite une boucle sur toutes les pages pour extraire les chiffres (√† coder).",
        "statut_analyse": "VLM ex√©cut√© sur la premi√®re page."
    },
    "full_text_sample": reader.pages[0].extract_text()[:500] + "..."
}

# --- 4. Export de l'analyse ---

# D√©finition des chemins de sortie
repertoire_sortie = "output_files"
nom_fichier_json = fichier_pdf.replace(".pdf", "_analyse.json") # Renomm√© pour plus de clart√©
chemin_sortie = os.path.join(repertoire_sortie, nom_fichier_json)

# Cr√©ation du r√©pertoire de sortie s'il n'existe pas
os.makedirs(repertoire_sortie, exist_ok=True)
print(f"Cr√©ation/v√©rification du r√©pertoire de sortie : {repertoire_sortie}/")

# --- 5. √âcriture du fichier JSON ---
try:
    with open(chemin_sortie, 'w', encoding='utf-8') as f:
        # Utilisation de la variable VLM corrig√©e: resultat_analyse_vlm
        json.dump(resultat_analyse_vlm, f, ensure_ascii=False, indent=4) 
        
    print(f"‚úÖ Exportation JSON VLM r√©ussie. Le fichier a √©t√© d√©pos√© √† : {chemin_sortie}")

except Exception as e:
    print(f"‚ùå ERREUR lors de l'√©criture du fichier JSON : {e}")
```